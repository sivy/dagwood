#!/usr/bin/env python
# -*- coding: utf-8 -*-

# quick and dirty DAG

import os
import dbutil
import io
import networkx as nx
from datetime import datetime

# import matplotlib
# matplotlib.use("Agg")
# import matplotlib.pyplot as plt

NODE_LINE_MIN = float(os.environ.get('NODE_LINE_MIN', "1"))
NODE_LINE_MAX = float(os.environ.get('NODE_LINE_MAX', "5"))
NODE_EDGES_CONST = float(os.environ.get('NODE_EDGES_CONST', "10"))

print(NODE_LINE_MIN, NODE_LINE_MAX, NODE_EDGES_CONST)

from flask import Flask, request, render_template, jsonify, make_response

# Support for gomix's 'front-end' and 'back-end' UI.
app = Flask(__name__, static_folder='public', template_folder='views')

# Set the app secret key from the secret environment variables.
app.secret = os.environ.get('SECRET')

def build_graph():
    nodes = dbutil.get_nodes_data()

    for n in nodes.values():
        classes = n["classes"]
        node_id = n['id']
        n.update({
            "id": n["label"],
            "label": n["title"],
            "color": dbutil.STROKE_COLORS[classes] if classes else "#666666",
            "fillcolor": dbutil.FILL_COLORS[classes] if classes else "#ffffff",
            # "href":"/?node=%s" % node_id,
            "href": "javascript:clickHandler(%s, '%s');" % (node_id, n["title"]),
            "target": "_top",
            "tooltip": "Click to add a dependency for '%s'" % n["title"],
            # "xlabel": "%s impact" % n["classes"],
        })

    graph = dbutil.get_graph()

    G = nx.DiGraph()
    G.add_nodes_from([(n["title"], n) for _, n in nodes.items()])

    for xfrom, xto in graph:
        G.add_edge(
            xfrom.title, xto.title,
            label=xfrom.effect or "",
            color=dbutil.STROKE_COLORS[xfrom.classes] if xfrom.classes else "#666666",
            weight=xfrom.weight)

    for node, node_data in list(G.nodes(data=True)):
        """
        Weight the line around nodes by how many connections
        they have
        """
        # incoming edges
        incoming = len(list(G.pred[node].items()))
        # outgoing edges
        outgoing = len(list(G.succ[node].items()))

        scale_factor = (
            NODE_LINE_MAX - NODE_LINE_MIN
        )/NODE_EDGES_CONST

        penwidth = NODE_LINE_MIN + scale_factor * (incoming + outgoing)

        # print("node: %s penwidth: %s" % (node, penwidth))
        node_data['penwidth'] = penwidth
        node_data['margin'] = .5 * scale_factor

    return G


@app.route('/')
def homepage():
    """Displays the homepage."""

    nodes = dbutil.get_nodes_by_id()
    classes = dbutil.CLASSES

    return render_template(
        'index.html',
        nodes=nodes, classes=classes, data=request.args, now=datetime.now())


@app.route('/graph.svg')
def graph_png():
    G = build_graph()

    A = nx.nx_agraph.to_agraph(G)
    A.graph_attr.update(
        label="Generated by Dagwood",
        rankdir='RL',
        fontname='Helvetica',
        fontsize='10',
        splines='ortho',
        pad=0.1,
    )

    A.node_attr.update(
        style="filled",
        shape='box',
        fontname='Helvetica',
        fontsize='12',
    )

    A.edge_attr.update(
        fontname='Helvetica',
        fontsize='9',
        arrowhead="vee",
        arrowsize=0.8,
    )

    svg_output = A.draw(format="svg", prog="dot")  # draw png
    response = make_response(svg_output)
    response.headers['Content-Type'] = 'image/svg+xml'
    return response


@app.route("/nodes.json")
def nodes():
    return jsonify(dbutil.get_nodes_data())


@app.route('/graph', methods=['GET', 'POST'])
def graph():
    """Simple API endpoint for dreams.
    In memory, ephemeral, like real dreams.
    """

    # Add a dream to the in-memory database, if given.
    if request.method == 'POST':
        data = None
        if request.is_json:
            data = request.get_json()
            print('JSON!')
            print(data)
        else:
            # Note: request args is bad form for POSTs
            # However, we're preserving this approach so that the HTML client
            # can still work
            data = request.args
            print('NOT JSON!')
            print(data)

        if 'from' in data:
            from_ = data['from']
            target = data['target']
            class_ = data['class']

            if not from_ or not target:
                make_response("No node to depend on or no node to connect o=to!", 400)

            from_node = dbutil.get_node(from_)
            if from_node:
                from_id = from_node.id

            else:
                from_id = dbutil.create_node(from_, classes=class_)

            dbutil.create_edge(from_id, target)

    # Return the list of remembered dreams.
    return jsonify(dbutil.get_graph_json())

if __name__ == '__main__':
    dbutil.bootstrap_db()
    app.run(debug=True)